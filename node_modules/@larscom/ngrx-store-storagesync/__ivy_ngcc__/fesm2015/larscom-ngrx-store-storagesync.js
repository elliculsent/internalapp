import { isPlainObject, cloneDeep, merge, isArray } from 'lodash-es';
import { InjectionToken, Directive, Inject, Input, HostListener, NgModule } from '@angular/core';
import { createAction, props, createFeatureSelector, createSelector, select, Store, createReducer, on, StoreModule } from '@ngrx/store';
import '@angular/forms';
import { Subscription } from 'rxjs';
import { filter } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/actions.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ngrx/store';
const INIT_ACTION = '@ngrx/store/init';
/** @type {?} */
const INIT_ACTION_EFFECTS = '@ngrx/effects/init';
/** @type {?} */
const UPDATE_ACTION = '@ngrx/store/update-reducers';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/rehydrate-state.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const dateMatcher = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
/**
 * \@internal Restores the resolved state from a storage location
 * \@param options the configurable options
 * \@return the restored state from the provided storage
 * @type {?}
 */
const rehydrateState = (/**
 * @template T
 * @param {?} __0
 * @return {?}
 */
({ storage, storageKeySerializer, features, storageError, version: currentVersion }) => {
    if (currentVersion) {
        try {
            /** @type {?} */
            const key = storageKeySerializer('version');
            /** @type {?} */
            const version = +storage.getItem(key);
            if (version < currentVersion) {
                return null;
            }
        }
        catch (e) {
            if (storageError) {
                storageError(e);
            }
            else {
                throw e;
            }
        }
    }
    /** @type {?} */
    const state = features.reduce((/**
     * @param {?} acc
     * @param {?} curr
     * @return {?}
     */
    (acc, curr) => {
        const { storageKeySerializerForFeature, stateKey, deserialize, storageForFeature } = curr;
        /** @type {?} */
        const key = storageKeySerializerForFeature
            ? storageKeySerializerForFeature(stateKey)
            : storageKeySerializer(stateKey);
        try {
            /** @type {?} */
            const featureState = storageForFeature ? storageForFeature.getItem(key) : storage.getItem(key);
            return featureState
                ? Object.assign(Object.assign({}, acc), {
                    [stateKey]: deserialize
                        ? deserialize(featureState)
                        : JSON.parse(featureState, (/**
                         * @param {?} _
                         * @param {?} value
                         * @return {?}
                         */
                        (_, value) => dateMatcher.test(String(value)) ? new Date(value) : value))
                }) : acc;
        }
        catch (e) {
            if (storageError) {
                storageError(e);
            }
            else {
                throw e;
            }
        }
    }), (/** @type {?} */ ({})));
    return Object.keys(state).length ? state : null;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/state-sync.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal Blacklisting
 * \@return the filtered state
 * @type {?}
 */
const excludeKeysFromState = (/**
 * @template T
 * @param {?} state
 * @param {?=} excludeKeys
 * @return {?}
 */
(state, excludeKeys) => {
    if (!excludeKeys) {
        return state;
    }
    /** @type {?} */
    const keyPairs = excludeKeys.map((/**
     * @param {?} key
     * @return {?}
     */
    key => ({
        rootKey: key.split('.')[0],
        nestedKey: key.split('.')[1]
    })));
    for (const key in state) {
        if (state.hasOwnProperty(key)) {
            /** @type {?} */
            const keyPair = keyPairs.find((/**
             * @param {?} pair
             * @return {?}
             */
            pair => pair.rootKey === key));
            /** @type {?} */
            const rootKey = keyPair ? keyPair.rootKey : null;
            /** @type {?} */
            const nestedKey = keyPair ? keyPair.nestedKey : null;
            switch (typeof state[key]) {
                case 'object': {
                    if (rootKey && !state[key]) {
                        delete state[key];
                    }
                    else if (rootKey && nestedKey) {
                        excludeKeysFromState(state[key], [...excludeKeys, nestedKey]);
                    }
                    else if (rootKey) {
                        delete state[key];
                    }
                    else {
                        excludeKeysFromState(state[key], excludeKeys);
                    }
                    break;
                }
                default: {
                    if (rootKey) {
                        delete state[key];
                    }
                }
            }
        }
    }
    return state;
});
/**
 * \@internal Remove empty objects from state
 * \@return the cleaned state
 * @type {?}
 */
const cleanState = (/**
 * @template T
 * @param {?} state
 * @return {?}
 */
(state) => {
    for (const key in state) {
        if (!isPlainObject(state[key])) {
            continue;
        }
        cleanState(state[key]);
        if (!Object.keys(state[key]).length) {
            delete state[key];
        }
    }
    return state;
});
/**
 * \@internal Sync state with storage
 * \@param state the next state
 * \@param options the configurable options
 * \@return the next state
 * @type {?}
 */
const stateSync = (/**
 * @template T
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { features, storage, storageKeySerializer, storageError, version: currentVersion }) => {
    if (currentVersion) {
        try {
            /** @type {?} */
            const key = storageKeySerializer('version');
            storage.setItem(key, String(currentVersion));
        }
        catch (e) {
            if (storageError) {
                storageError(e);
            }
            else {
                throw e;
            }
        }
    }
    features
        .filter((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stateKey }) => state[stateKey] !== undefined))
        .filter((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stateKey, shouldSync }) => (shouldSync ? shouldSync(state[stateKey], state) : true)))
        .forEach((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stateKey, excludeKeys, storageKeySerializerForFeature, serialize, storageForFeature }) => {
        /** @type {?} */
        const featureState = cloneDeep(state[stateKey]);
        /** @type {?} */
        const filteredState = cleanState(excludeKeysFromState(featureState, excludeKeys));
        if (isPlainObject(filteredState) && !Object.keys(filteredState).length) {
            return;
        }
        /** @type {?} */
        const key = storageKeySerializerForFeature
            ? storageKeySerializerForFeature(stateKey)
            : storageKeySerializer(stateKey);
        /** @type {?} */
        const value = serialize ? serialize(filteredState) : JSON.stringify(filteredState);
        try {
            if (storageForFeature) {
                storageForFeature.setItem(key, value);
            }
            else {
                storage.setItem(key, value);
            }
        }
        catch (e) {
            if (storageError) {
                storageError(e);
            }
            else {
                throw e;
            }
        }
    }));
    return state;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/storage-sync.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The StorageSync Meta Reducer for \@ngrx/store.
 *
 * \@param options The configuration for the meta reducer
 *
 * Check out github for more information.
 * @see https://github.com/larscom/ngrx-store-storagesync
 *
 * \@return the meta reducer function
 * @type {?}
 */
const storageSync = (/**
 * @template T
 * @param {?} options
 * @return {?}
 */
(options) => (/**
 * @param {?} reducer
 * @return {?}
 */
(reducer) => {
    /** @type {?} */
    const config = Object.assign({ rehydrate: true, storageKeySerializer: (/**
         * @param {?} key
         * @return {?}
         */
        (key) => key), rehydrateStateMerger: (/**
         * @param {?} nextState
         * @param {?} rehydratedState
         * @return {?}
         */
        (nextState, rehydratedState) => merge({}, nextState, rehydratedState)) }, options);
    const { rehydrate, rehydrateStateMerger } = config;
    /** @type {?} */
    const revivedState = rehydrate ? rehydrateState(config) : null;
    return (/**
     * @param {?} state
     * @param {?} action
     * @return {?}
     */
    (state, action) => {
        /** @type {?} */
        const nextState = action.type === INIT_ACTION ? reducer(state, action) : Object.assign({}, state);
        /** @type {?} */
        const shouldMerge = revivedState && [INIT_ACTION, UPDATE_ACTION].includes(action.type);
        /** @type {?} */
        const mergedState = reducer(shouldMerge ? rehydrateStateMerger(nextState, revivedState) : nextState, action);
        return [INIT_ACTION, INIT_ACTION_EFFECTS].includes(action.type) ? mergedState : stateSync(mergedState, config);
    });
}));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/form-sync.constants.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FORM_SYNC_STORE_KEY = 'formSync';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/providers/form-sync.providers.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const FORM_SYNC_CONFIG = new InjectionToken('FORM_SYNC_CONFIG', {
    factory: (/**
     * @return {?}
     */
    () => ({ syncOnSubmit: false, syncRawValue: false, syncValidOnly: false }))
});
/** @type {?} */
const FORM_SYNC_REDUCER = new InjectionToken('FORM_SYNC_REDUCER');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/store/form.actions.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const setForm = createAction('@larscom/form-sync/set', props());
/** @type {?} */
const patchForm = createAction('@larscom/form-sync/patch', props());
/** @type {?} */
const resetForm = createAction('@larscom/form-sync/reset', props());
/** @type {?} */
const deleteForm = createAction('@larscom/form-sync/delete', props());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/store/form.selectors.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const getFormSyncState = createFeatureSelector(FORM_SYNC_STORE_KEY);
const ɵ0 = /**
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { id }) => state[id];
/** @type {?} */
const getFormSyncValue = createSelector(getFormSyncState, (ɵ0));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/directives/form-group.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormGroupDirective {
    /**
     * @param {?} config
     * @param {?} store
     */
    constructor(config, store) {
        this.config = config;
        this.store = store;
        this.formGroupSync = true;
        this.subscriptions = new Subscription();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.formGroupId) {
            return;
        }
        const { syncOnSubmit, syncValidOnly, syncRawValue } = this.config;
        this.subscriptions.add(this.formGroup.valueChanges
            .pipe(filter((/**
         * @return {?}
         */
        () => this.formGroupSync)), filter((/**
         * @return {?}
         */
        () => !(syncValidOnly && !this.formGroup.valid))), filter((/**
         * @return {?}
         */
        () => !syncOnSubmit)))
            .subscribe((/**
         * @return {?}
         */
        () => this.dispatch(syncRawValue))));
        this.subscriptions.add(this.store
            .pipe(filter((/**
         * @return {?}
         */
        () => this.formGroupSync)), select(getFormSyncValue, { id: this.formGroupId }), filter((/**
         * @param {?} value
         * @return {?}
         */
        value => value != null)))
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => this.formGroup.patchValue(value, { emitEvent: false }))));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    /**
     * @return {?}
     */
    onSubmit() {
        if (!this.formGroupId || !this.formGroupSync) {
            return;
        }
        const { syncOnSubmit, syncValidOnly, syncRawValue } = this.config;
        if (!syncOnSubmit) {
            return;
        }
        if (syncValidOnly && !this.formGroup.valid) {
            return;
        }
        this.dispatch(syncRawValue);
    }
    /**
     * @private
     * @param {?} syncRawValue
     * @return {?}
     */
    dispatch(syncRawValue) {
        /** @type {?} */
        const value = syncRawValue ? this.formGroup.getRawValue() : this.formGroup.value;
        this.store.dispatch(patchForm({ id: this.formGroupId, value }));
    }
}
FormGroupDirective.ɵfac = function FormGroupDirective_Factory(t) { return new (t || FormGroupDirective)(ɵngcc0.ɵɵdirectiveInject(FORM_SYNC_CONFIG), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Store)); };
FormGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FormGroupDirective, selectors: [["", "formGroup", ""]], hostBindings: function FormGroupDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("submit", function FormGroupDirective_submit_HostBindingHandler() { return ctx.onSubmit(); });
    } }, inputs: { formGroupSync: "formGroupSync", formGroup: "formGroup", formGroupId: "formGroupId" } });
/** @nocollapse */
FormGroupDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [FORM_SYNC_CONFIG,] }] },
    { type: Store }
];
FormGroupDirective.propDecorators = {
    formGroup: [{ type: Input }],
    formGroupId: [{ type: Input }],
    formGroupSync: [{ type: Input }],
    onSubmit: [{ type: HostListener, args: ['submit',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormGroupDirective, [{
        type: Directive,
        args: [{
                selector: '[formGroup]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [FORM_SYNC_CONFIG]
            }] }, { type: ɵngcc1.Store }]; }, { formGroupSync: [{
            type: Input
        }], 
    /**
     * @return {?}
     */
    onSubmit: [{
            type: HostListener,
            args: ['submit']
        }], formGroup: [{
            type: Input
        }], formGroupId: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    FormGroupDirective.prototype.formGroup;
    /** @type {?} */
    FormGroupDirective.prototype.formGroupId;
    /** @type {?} */
    FormGroupDirective.prototype.formGroupSync;
    /**
     * @type {?}
     * @private
     */
    FormGroupDirective.prototype.subscriptions;
    /**
     * @type {?}
     * @private
     */
    FormGroupDirective.prototype.config;
    /**
     * @type {?}
     * @private
     */
    FormGroupDirective.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/store/form.reducer.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function IFormSyncState() { }
// tslint:disable: no-shadowed-variable
const ɵ0$1 = /**
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { id, value }) => (Object.assign(Object.assign({}, state), { [id]: value })), ɵ1 = /**
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { id, value }) => merge({}, Object.assign({}, state), { [id]: value }), ɵ2 = /**
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { id }) => {
    /** @type {?} */
    const reset = (/**
     * @param {?} slice
     * @return {?}
     */
    (slice) => {
        for (const property in slice) {
            if (!slice.hasOwnProperty(property)) {
                continue;
            }
            if (isPlainObject(slice[property])) {
                reset(slice[property]);
            }
            else if (isArray(slice[property])) {
                Array(slice[property]).forEach((/**
                 * @param {?} p
                 * @return {?}
                 */
                p => reset(p)));
            }
            else {
                slice[property] = null;
            }
        }
        return slice;
    });
    /** @type {?} */
    const value = reset(cloneDeep(state[id]));
    return Object.assign(Object.assign({}, state), { [id]: value });
}, ɵ3 = /**
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { id }) => (Object.assign(Object.assign({}, state), { [id]: undefined }));
/**
 * The form sync reducer for \@ngrx/store.
 * @type {?}
 */
const formSyncReducer = createReducer(Object(), on(setForm, (ɵ0$1)), on(patchForm, (ɵ1)), on(resetForm, (ɵ2)), on(deleteForm, (ɵ3)));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/form-sync.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormSyncModule {
    /**
     * Import 'FormSyncModule.forRoot()' only once.
     * Use 'FormSyncModule' for additional imports
     * inside feature modules.
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: FormSyncModule,
            providers: [
                {
                    provide: FORM_SYNC_REDUCER,
                    useValue: formSyncReducer
                }
            ]
        };
    }
}
FormSyncModule.ɵfac = function FormSyncModule_Factory(t) { return new (t || FormSyncModule)(); };
FormSyncModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FormSyncModule });
FormSyncModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[StoreModule.forFeature(FORM_SYNC_STORE_KEY, FORM_SYNC_REDUCER)]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormSyncModule, { declarations: [FormGroupDirective], imports: [ɵngcc1.StoreFeatureModule], exports: [FormGroupDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormSyncModule, [{
        type: NgModule,
        args: [{
                declarations: [FormGroupDirective],
                imports: [StoreModule.forFeature(FORM_SYNC_STORE_KEY, FORM_SYNC_REDUCER)],
                exports: [FormGroupDirective]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: lib/form-sync/public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: larscom-ngrx-store-storagesync.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FORM_SYNC_CONFIG, FORM_SYNC_REDUCER, FORM_SYNC_STORE_KEY, FormGroupDirective, FormSyncModule, deleteForm, formSyncReducer, getFormSyncValue, patchForm, resetForm, setForm, storageSync, getFormSyncState as ɵa };

//# sourceMappingURL=larscom-ngrx-store-storagesync.js.map