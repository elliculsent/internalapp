/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/models/storage-sync-options.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
export function IStorageSyncOptions() { }
if (false) {
    /**
     * By default, states are not synced, provide the feature states you want to sync.
     * @type {?}
     */
    IStorageSyncOptions.prototype.features;
    /**
     * Provide the storage type to sync the state to, it can be any storage which implements the 'Storage' interface.
     * @type {?}
     */
    IStorageSyncOptions.prototype.storage;
    /**
     * Give the state a version number. Version number will be checked on rehydration.
     *
     * Skips rehydration if version from storage < version
     * @type {?|undefined}
     */
    IStorageSyncOptions.prototype.version;
    /**
     * Function that gets executed on a storage error
     * \@param error the error that occurred
     * @type {?|undefined}
     */
    IStorageSyncOptions.prototype.storageError;
    /**
     * Restore last known state from storage on startup
     * @type {?|undefined}
     */
    IStorageSyncOptions.prototype.rehydrate;
    /**
     * Serializer for storage keys
     * \@param key the storage item key
     * @type {?|undefined}
     */
    IStorageSyncOptions.prototype.storageKeySerializer;
    /**
     * Custom state merge function after rehydration (by default it does a deep merge)
     * \@param state the next state
     * \@param rehydratedState the state resolved from a storage location
     * @type {?|undefined}
     */
    IStorageSyncOptions.prototype.rehydrateStateMerger;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1zeW5jLW9wdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3J4LXN0b3JlLXN0b3JhZ2VzeW5jL3NyYy9saWIvc3RvcmFnZS1zeW5jL21vZGVscy9zdG9yYWdlLXN5bmMtb3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFQSx5Q0FtQ0M7Ozs7OztJQS9CQyx1Q0FBb0M7Ozs7O0lBSXBDLHNDQUFpQjs7Ozs7OztJQU1qQixzQ0FBaUI7Ozs7OztJQUtqQiwyQ0FBb0M7Ozs7O0lBSXBDLHdDQUFvQjs7Ozs7O0lBS3BCLG1EQUErQzs7Ozs7OztJQU0vQyxtREFBMkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRmVhdHVyZU9wdGlvbnMgfSBmcm9tICcuL2ZlYXR1cmUtb3B0aW9ucyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN0b3JhZ2VTeW5jT3B0aW9uczxUPiB7XG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBzdGF0ZXMgYXJlIG5vdCBzeW5jZWQsIHByb3ZpZGUgdGhlIGZlYXR1cmUgc3RhdGVzIHlvdSB3YW50IHRvIHN5bmMuXG4gICAqL1xuICBmZWF0dXJlczogQXJyYXk8SUZlYXR1cmVPcHRpb25zPFQ+PjtcbiAgLyoqXG4gICAqIFByb3ZpZGUgdGhlIHN0b3JhZ2UgdHlwZSB0byBzeW5jIHRoZSBzdGF0ZSB0bywgaXQgY2FuIGJlIGFueSBzdG9yYWdlIHdoaWNoIGltcGxlbWVudHMgdGhlICdTdG9yYWdlJyBpbnRlcmZhY2UuXG4gICAqL1xuICBzdG9yYWdlOiBTdG9yYWdlO1xuICAvKipcbiAgICogR2l2ZSB0aGUgc3RhdGUgYSB2ZXJzaW9uIG51bWJlci4gVmVyc2lvbiBudW1iZXIgd2lsbCBiZSBjaGVja2VkIG9uIHJlaHlkcmF0aW9uLlxuICAgKlxuICAgKiBTa2lwcyByZWh5ZHJhdGlvbiBpZiB2ZXJzaW9uIGZyb20gc3RvcmFnZSA8IHZlcnNpb25cbiAgICovXG4gIHZlcnNpb24/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGdldHMgZXhlY3V0ZWQgb24gYSBzdG9yYWdlIGVycm9yXG4gICAqIEBwYXJhbSBlcnJvciB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZFxuICAgKi9cbiAgc3RvcmFnZUVycm9yPzogKGVycm9yOiBhbnkpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBSZXN0b3JlIGxhc3Qga25vd24gc3RhdGUgZnJvbSBzdG9yYWdlIG9uIHN0YXJ0dXBcbiAgICovXG4gIHJlaHlkcmF0ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTZXJpYWxpemVyIGZvciBzdG9yYWdlIGtleXNcbiAgICogQHBhcmFtIGtleSB0aGUgc3RvcmFnZSBpdGVtIGtleVxuICAgKi9cbiAgc3RvcmFnZUtleVNlcmlhbGl6ZXI/OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcbiAgLyoqXG4gICAqIEN1c3RvbSBzdGF0ZSBtZXJnZSBmdW5jdGlvbiBhZnRlciByZWh5ZHJhdGlvbiAoYnkgZGVmYXVsdCBpdCBkb2VzIGEgZGVlcCBtZXJnZSlcbiAgICogQHBhcmFtIHN0YXRlIHRoZSBuZXh0IHN0YXRlXG4gICAqIEBwYXJhbSByZWh5ZHJhdGVkU3RhdGUgdGhlIHN0YXRlIHJlc29sdmVkIGZyb20gYSBzdG9yYWdlIGxvY2F0aW9uXG4gICAqL1xuICByZWh5ZHJhdGVTdGF0ZU1lcmdlcj86IChzdGF0ZTogVCwgcmVoeWRyYXRlZFN0YXRlOiBUKSA9PiBUO1xufVxuIl19