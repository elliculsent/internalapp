/**
 * @fileoverview added by tsickle
 * Generated from: lib/storage-sync/state-sync.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { cloneDeep, isPlainObject } from 'lodash-es';
/**
 * \@internal Blacklisting
 * \@return the filtered state
 * @type {?}
 */
export const excludeKeysFromState = (/**
 * @template T
 * @param {?} state
 * @param {?=} excludeKeys
 * @return {?}
 */
(state, excludeKeys) => {
    if (!excludeKeys) {
        return state;
    }
    /** @type {?} */
    const keyPairs = excludeKeys.map((/**
     * @param {?} key
     * @return {?}
     */
    key => ({
        rootKey: key.split('.')[0],
        nestedKey: key.split('.')[1]
    })));
    for (const key in state) {
        if (state.hasOwnProperty(key)) {
            /** @type {?} */
            const keyPair = keyPairs.find((/**
             * @param {?} pair
             * @return {?}
             */
            pair => pair.rootKey === key));
            /** @type {?} */
            const rootKey = keyPair ? keyPair.rootKey : null;
            /** @type {?} */
            const nestedKey = keyPair ? keyPair.nestedKey : null;
            switch (typeof state[key]) {
                case 'object': {
                    if (rootKey && !state[key]) {
                        delete state[key];
                    }
                    else if (rootKey && nestedKey) {
                        excludeKeysFromState(state[key], [...excludeKeys, nestedKey]);
                    }
                    else if (rootKey) {
                        delete state[key];
                    }
                    else {
                        excludeKeysFromState(state[key], excludeKeys);
                    }
                    break;
                }
                default: {
                    if (rootKey) {
                        delete state[key];
                    }
                }
            }
        }
    }
    return state;
});
/**
 * \@internal Remove empty objects from state
 * \@return the cleaned state
 * @type {?}
 */
export const cleanState = (/**
 * @template T
 * @param {?} state
 * @return {?}
 */
(state) => {
    for (const key in state) {
        if (!isPlainObject(state[key])) {
            continue;
        }
        cleanState(state[key]);
        if (!Object.keys(state[key]).length) {
            delete state[key];
        }
    }
    return state;
});
/**
 * \@internal Sync state with storage
 * \@param state the next state
 * \@param options the configurable options
 * \@return the next state
 * @type {?}
 */
export const stateSync = (/**
 * @template T
 * @param {?} state
 * @param {?} __1
 * @return {?}
 */
(state, { features, storage, storageKeySerializer, storageError, version: currentVersion }) => {
    if (currentVersion) {
        try {
            /** @type {?} */
            const key = storageKeySerializer('version');
            storage.setItem(key, String(currentVersion));
        }
        catch (e) {
            if (storageError) {
                storageError(e);
            }
            else {
                throw e;
            }
        }
    }
    features
        .filter((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stateKey }) => state[stateKey] !== undefined))
        .filter((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stateKey, shouldSync }) => (shouldSync ? shouldSync(state[stateKey], state) : true)))
        .forEach((/**
     * @param {?} __0
     * @return {?}
     */
    ({ stateKey, excludeKeys, storageKeySerializerForFeature, serialize, storageForFeature }) => {
        /** @type {?} */
        const featureState = cloneDeep(state[stateKey]);
        /** @type {?} */
        const filteredState = cleanState(excludeKeysFromState(featureState, excludeKeys));
        if (isPlainObject(filteredState) && !Object.keys(filteredState).length) {
            return;
        }
        /** @type {?} */
        const key = storageKeySerializerForFeature
            ? storageKeySerializerForFeature(stateKey)
            : storageKeySerializer(stateKey);
        /** @type {?} */
        const value = serialize ? serialize(filteredState) : JSON.stringify(filteredState);
        try {
            if (storageForFeature) {
                storageForFeature.setItem(key, value);
            }
            else {
                storage.setItem(key, value);
            }
        }
        catch (e) {
            if (storageError) {
                storageError(e);
            }
            else {
                throw e;
            }
        }
    }));
    return state;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtc3luYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25ncngtc3RvcmUtc3RvcmFnZXN5bmMvc3JjL2xpYi9zdG9yYWdlLXN5bmMvc3RhdGUtc3luYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFFLE1BQU0sV0FBVyxDQUFDOzs7Ozs7QUFRckQsTUFBTSxPQUFPLG9CQUFvQjs7Ozs7O0FBQUcsQ0FBSSxLQUFpQixFQUFFLFdBQXNCLEVBQWMsRUFBRTtJQUMvRixJQUFJLENBQUMsV0FBVyxFQUFFO1FBQ2hCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7O1VBRUssUUFBUSxHQUFHLFdBQVcsQ0FBQyxHQUFHOzs7O0lBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixTQUFTLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0IsQ0FBQyxFQUFDO0lBRUgsS0FBSyxNQUFNLEdBQUcsSUFBSSxLQUFLLEVBQUU7UUFDdkIsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFOztrQkFDdkIsT0FBTyxHQUFHLFFBQVEsQ0FBQyxJQUFJOzs7O1lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxLQUFLLEdBQUcsRUFBQzs7a0JBQ3JELE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUk7O2tCQUMxQyxTQUFTLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJO1lBRXBELFFBQVEsT0FBTyxLQUFLLENBQUMsR0FBRyxD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QUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxFQUFFO1lBQ3RFLE9BQU87U0FDUjs7Y0FFSyxHQUFHLEdBQUcsOEJBQThCO1lBQ3hDLENBQUMsQ0FBQyw4QkFBOEIsQ0FBQyxRQUFRLENBQUM7WUFDMUMsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQzs7Y0FFNUIsS0FBSyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQztRQUVsRixJQUFJO1lBQ0YsSUFBSSxpQkFBaUIsRUFBRTtnQkFDckIsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN2QztpQkFBTTtnQkFDTCxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUM3QjtTQUNGO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixJQUFJLFlBQVksRUFBRTtnQkFDaEIsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pCO2lCQUFNO2dCQUNMLE1BQU0sQ0FBQyxDQUFDO2FBQ1Q7U0FDRjtJQUNILENBQUMsRUFBQyxDQUFDO0lBRUwsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgSVN0b3JhZ2VTeW5jT3B0aW9ucyB9IGZyb20gJy4vbW9kZWxzL3N0b3JhZ2Utc3luYy1vcHRpb25zJztcblxuXG4vKipcbiAqIEBpbnRlcm5hbCBCbGFja2xpc3RpbmdcbiAqIEByZXR1cm5zIHRoZSBmaWx0ZXJlZCBzdGF0ZVxuICovXG5leHBvcnQgY29uc3QgZXhjbHVkZUtleXNGcm9tU3RhdGUgPSA8VD4oc3RhdGU6IFBhcnRpYWw8VD4sIGV4Y2x1ZGVLZXlzPzogc3RyaW5nW10pOiBQYXJ0aWFsPFQ+ID0+IHtcbiAgaWYgKCFleGNsdWRlS2V5cykge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGNvbnN0IGtleVBhaXJzID0gZXhjbHVkZUtleXMubWFwKGtleSA9PiAoe1xuICAgIHJvb3RLZXk6IGtleS5zcGxpdCgnLicpWzBdLFxuICAgIG5lc3RlZEtleToga2V5LnNwbGl0KCcuJylbMV1cbiAgfSkpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBrZXlQYWlycy5maW5kKHBhaXIgPT4gcGFpci5yb290S2V5ID09PSBrZXkpO1xuICAgICAgY29uc3Qgcm9vdEtleSA9IGtleVBhaXIgPyBrZXlQYWlyLnJvb3RLZXkgOiBudWxsO1xuICAgICAgY29uc3QgbmVzdGVkS2V5ID0ga2V5UGFpciA/IGtleVBhaXIubmVzdGVkS2V5IDogbnVsbDtcblxuICAgICAgc3dpdGNoICh0eXBlb2Ygc3RhdGVba2V5XSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgaWYgKHJvb3RLZXkgJiYgIXN0YXRlW2tleV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdEtleSAmJiBuZXN0ZWRLZXkpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVLZXlzRnJvbVN0YXRlPFQ+KHN0YXRlW2tleV0sIFsuLi5leGNsdWRlS2V5cywgbmVzdGVkS2V5XSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290S2V5KSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhjbHVkZUtleXNGcm9tU3RhdGU8VD4oc3RhdGVba2V5XSwgZXhjbHVkZUtleXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgaWYgKHJvb3RLZXkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbCBSZW1vdmUgZW1wdHkgb2JqZWN0cyBmcm9tIHN0YXRlXG4gKiBAcmV0dXJucyB0aGUgY2xlYW5lZCBzdGF0ZVxuICovXG5leHBvcnQgY29uc3QgY2xlYW5TdGF0ZSA9IDxUPihzdGF0ZTogUGFydGlhbDxUPik6IFBhcnRpYWw8VD4gPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzdGF0ZVtrZXldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY2xlYW5TdGF0ZTxUPihzdGF0ZVtrZXldKTtcblxuICAgIGlmICghT2JqZWN0LmtleXMoc3RhdGVba2V5XSkubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWwgU3luYyBzdGF0ZSB3aXRoIHN0b3JhZ2VcbiAqIEBwYXJhbSBzdGF0ZSB0aGUgbmV4dCBzdGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGNvbmZpZ3VyYWJsZSBvcHRpb25zXG4gKiBAcmV0dXJucyB0aGUgbmV4dCBzdGF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3RhdGVTeW5jID0gPFQ+KFxuICBzdGF0ZTogVCxcbiAgeyBmZWF0dXJlcywgc3RvcmFnZSwgc3RvcmFnZUtleVNlcmlhbGl6ZXIsIHN0b3JhZ2VFcnJvciwgdmVyc2lvbjogY3VycmVudFZlcnNpb24gfTogSVN0b3JhZ2VTeW5jT3B0aW9uczxUPlxuKTogVCA9PiB7XG4gIGlmIChjdXJyZW50VmVyc2lvbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXkgPSBzdG9yYWdlS2V5U2VyaWFsaXplcigndmVyc2lvbicpO1xuICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgU3RyaW5nKGN1cnJlbnRWZXJzaW9uKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHN0b3JhZ2VFcnJvcikge1xuICAgICAgICBzdG9yYWdlRXJyb3IoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZlYXR1cmVzXG4gICAgLmZpbHRlcigoeyBzdGF0ZUtleSB9KSA9PiBzdGF0ZVtzdGF0ZUtleV0gIT09IHVuZGVmaW5lZClcbiAgICAuZmlsdGVyKCh7IHN0YXRlS2V5LCBzaG91bGRTeW5jIH0pID0+IChzaG91bGRTeW5jID8gc2hvdWxkU3luYyhzdGF0ZVtzdGF0ZUtleV0sIHN0YXRlKSA6IHRydWUpKVxuICAgIC5mb3JFYWNoKCh7IHN0YXRlS2V5LCBleGNsdWRlS2V5cywgc3RvcmFnZUtleVNlcmlhbGl6ZXJGb3JGZWF0dXJlLCBzZXJpYWxpemUsIHN0b3JhZ2VGb3JGZWF0dXJlIH0pID0+IHtcbiAgICAgIGNvbnN0IGZlYXR1cmVTdGF0ZSA9IGNsb25lRGVlcDxQYXJ0aWFsPFQ+PihzdGF0ZVtzdGF0ZUtleV0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRTdGF0ZSA9IGNsZWFuU3RhdGU8VD4oZXhjbHVkZUtleXNGcm9tU3RhdGU8VD4oZmVhdHVyZVN0YXRlLCBleGNsdWRlS2V5cykpO1xuXG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChmaWx0ZXJlZFN0YXRlKSAmJiAhT2JqZWN0LmtleXMoZmlsdGVyZWRTdGF0ZSkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gc3RvcmFnZUtleVNlcmlhbGl6ZXJGb3JGZWF0dXJlXG4gICAgICAgID8gc3RvcmFnZUtleVNlcmlhbGl6ZXJGb3JGZWF0dXJlKHN0YXRlS2V5KVxuICAgICAgICA6IHN0b3JhZ2VLZXlTZXJpYWxpemVyKHN0YXRlS2V5KTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemUgPyBzZXJpYWxpemUoZmlsdGVyZWRTdGF0ZSkgOiBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZFN0YXRlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN0b3JhZ2VGb3JGZWF0dXJlKSB7XG4gICAgICAgICAgc3RvcmFnZUZvckZlYXR1cmUuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHN0b3JhZ2VFcnJvcikge1xuICAgICAgICAgIHN0b3JhZ2VFcnJvcihlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcbiJdfQ==