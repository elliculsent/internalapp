{"version":3,"file":"ngrx-component-store.js","sources":["../src/debounce-sync.ts","../src/component-store.ts","../src/tap-response.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport {\n  asapScheduler,\n  MonoTypeOperatorFunction,\n  Observable,\n  Subscription,\n} from 'rxjs';\n\nexport function debounceSync<T>(): MonoTypeOperatorFunction<T> {\n  return (source) =>\n    new Observable<T>((observer) => {\n      let actionSubscription: Subscription | undefined;\n      let actionValue: T | undefined;\n      const rootSubscription = new Subscription();\n      rootSubscription.add(\n        source.subscribe({\n          complete: () => {\n            if (actionSubscription) {\n              observer.next(actionValue);\n            }\n            observer.complete();\n          },\n          error: (error) => {\n            observer.error(error);\n          },\n          next: (value) => {\n            actionValue = value;\n            if (!actionSubscription) {\n              actionSubscription = asapScheduler.schedule(() => {\n                observer.next(actionValue);\n                actionSubscription = undefined;\n              });\n              rootSubscription.add(actionSubscription);\n            }\n          },\n        })\n      );\n      return rootSubscription;\n    });\n}\n","import {\n  isObservable,\n  Observable,\n  of,\n  ReplaySubject,\n  Subscription,\n  throwError,\n  combineLatest,\n  Subject,\n  queueScheduler,\n  scheduled,\n} from 'rxjs';\nimport {\n  concatMap,\n  takeUntil,\n  withLatestFrom,\n  map,\n  distinctUntilChanged,\n  shareReplay,\n  take,\n} from 'rxjs/operators';\nimport { debounceSync } from './debounce-sync';\nimport {\n  Injectable,\n  OnDestroy,\n  Optional,\n  InjectionToken,\n  Inject,\n} from '@angular/core';\n\nexport interface SelectConfig {\n  debounce?: boolean;\n}\n\nexport const INITIAL_STATE_TOKEN = new InjectionToken(\n  '@ngrx/component-store Initial State'\n);\n\nexport type SelectorResults<Selectors extends Observable<unknown>[]> = {\n  [Key in keyof Selectors]: Selectors[Key] extends Observable<infer U>\n    ? U\n    : never;\n};\n\nexport type Projector<Selectors extends Observable<unknown>[], Result> = (\n  ...args: SelectorResults<Selectors>\n) => Result;\n\n@Injectable()\nexport class ComponentStore<T extends object> implements OnDestroy {\n  // Should be used only in ngOnDestroy.\n  private readonly destroySubject$ = new ReplaySubject<void>(1);\n  // Exposed to any extending Store to be used for the teardown.\n  readonly destroy$ = this.destroySubject$.asObservable();\n\n  private readonly stateSubject$ = new ReplaySubject<T>(1);\n  private isInitialized = false;\n  private notInitializedErrorMessage =\n    `${this.constructor.name} has not been initialized yet. ` +\n    `Please make sure it is initialized before updating/getting.`;\n  // Needs to be after destroy$ is declared because it's used in select.\n  readonly state$: Observable<T> = this.select((s) => s);\n\n  constructor(@Optional() @Inject(INITIAL_STATE_TOKEN) defaultState?: T) {\n    // State can be initialized either through constructor or setState.\n    if (defaultState) {\n      this.initState(defaultState);\n    }\n  }\n\n  /** Completes all relevant Observable streams. */\n  ngOnDestroy() {\n    this.stateSubject$.complete();\n    this.destroySubject$.next();\n  }\n\n  /**\n   * Creates an updater.\n   *\n   * Throws an error if updater is called with synchronous values (either\n   * imperative value or Observable that is synchronous) before ComponentStore\n   * is initialized. If called with async Observable before initialization then\n   * state will not be updated and subscription would be closed.\n   *\n   * @param updaterFn A static updater function that takes 2 parameters (the\n   * current state and an argument object) and returns a new instance of the\n   * state.\n   * @return A function that accepts one argument which is forwarded as the\n   *     second argument to `updaterFn`. Every time this function is called\n   *     subscribers will be notified of the state change.\n   */\n  updater<\n    // Allow to force-provide the type\n    ProvidedType = void,\n    // This type is derived from the `value` property, defaulting to void if it's missing\n    OriginType = ProvidedType,\n    // The Value type is assigned from the Origin\n    ValueType = OriginType,\n    // Return either an empty callback or a function requiring specific types as inputs\n    ReturnType = OriginType extends void\n      ? () => void\n      : (observableOrValue: ValueType | Observable<ValueType>) => Subscription\n  >(updaterFn: (state: T, value: OriginType) => T): ReturnType {\n    return (((\n      observableOrValue?: OriginType | Observable<OriginType>\n    ): Subscription => {\n      let initializationError: Error | undefined;\n      // We can receive either the value or an observable. In case it's a\n      // simple value, we'll wrap it with `of` operator to turn it into\n      // Observable.\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      const subscription = observable$\n        .pipe(\n          concatMap((value) =>\n            this.isInitialized\n              ? // Push the value into queueScheduler\n                scheduled([value], queueScheduler).pipe(\n                  withLatestFrom(this.stateSubject$)\n                )\n              : // If state was not initialized, we'll throw an error.\n                throwError(new Error(this.notInitializedErrorMessage))\n          ),\n          takeUntil(this.destroy$)\n        )\n        .subscribe({\n          next: ([value, currentState]) => {\n            this.stateSubject$.next(updaterFn(currentState, value!));\n          },\n          error: (error: Error) => {\n            initializationError = error;\n            this.stateSubject$.error(error);\n          },\n        });\n\n      if (initializationError) {\n        // prettier-ignore\n        throw /** @type {!Error} */ (initializationError);\n      }\n      return subscription;\n    }) as unknown) as ReturnType;\n  }\n\n  /**\n   * Initializes state. If it was already initialized then it resets the\n   * state.\n   */\n  private initState(state: T): void {\n    scheduled([state], queueScheduler).subscribe((s) => {\n      this.isInitialized = true;\n      this.stateSubject$.next(s);\n    });\n  }\n\n  /**\n   * Sets the state specific value.\n   * @param stateOrUpdaterFn object of the same type as the state or an\n   * updaterFn, returning such object.\n   */\n  setState(stateOrUpdaterFn: T | ((state: T) => T)): void {\n    if (typeof stateOrUpdaterFn !== 'function') {\n      this.initState(stateOrUpdaterFn);\n    } else {\n      this.updater(stateOrUpdaterFn as (state: T) => T)();\n    }\n  }\n\n  /**\n   * Patches the state with provided partial state.\n   *\n   * @param partialStateOrUpdaterFn a partial state or a partial updater\n   * function that accepts the state and returns the partial state.\n   * @throws Error if the state is not initialized.\n   */\n  patchState(\n    partialStateOrUpdaterFn: Partial<T> | ((state: T) => Partial<T>)\n  ): void {\n    this.setState((state) => {\n      const patchedState =\n        typeof partialStateOrUpdaterFn === 'function'\n          ? partialStateOrUpdaterFn(state)\n          : partialStateOrUpdaterFn;\n\n      return {\n        ...state,\n        ...patchedState,\n      };\n    });\n  }\n\n  protected get(): T;\n  protected get<R>(projector: (s: T) => R): R;\n  protected get<R>(projector?: (s: T) => R): R | T {\n    if (!this.isInitialized) {\n      throw new Error(this.notInitializedErrorMessage);\n    }\n    let value: R | T;\n\n    this.stateSubject$.pipe(take(1)).subscribe((state) => {\n      value = projector ? projector(state) : state;\n    });\n    return value!;\n  }\n\n  /**\n   * Creates a selector.\n   *\n   * @param projector A pure projection function that takes the current state and\n   *   returns some new slice/projection of that state.\n   * @param config SelectConfig that changes the behavior of selector, including\n   *   the debouncing of the values until the state is settled.\n   * @return An observable of the projector results.\n   */\n  select<Result>(\n    projector: (s: T) => Result,\n    config?: SelectConfig\n  ): Observable<Result>;\n  select<Selectors extends Observable<unknown>[], Result>(\n    ...args: [...selectors: Selectors, projector: Projector<Selectors, Result>]\n  ): Observable<Result>;\n  select<Selectors extends Observable<unknown>[], Result>(\n    ...args: [\n      ...selectors: Selectors,\n      projector: Projector<Selectors, Result>,\n      config: SelectConfig\n    ]\n  ): Observable<Result>;\n  select<\n    Selectors extends Array<Observable<unknown> | SelectConfig | ProjectorFn>,\n    Result,\n    ProjectorFn = (...a: unknown[]) => Result\n  >(...args: Selectors): Observable<Result> {\n    const { observables, projector, config } = processSelectorArgs<\n      Selectors,\n      Result\n    >(args);\n\n    let observable$: Observable<Result>;\n    // If there are no Observables to combine, then we'll just map the value.\n    if (observables.length === 0) {\n      observable$ = this.stateSubject$.pipe(\n        config.debounce ? debounceSync() : (source$) => source$,\n        map(projector)\n      );\n    } else {\n      // If there are multiple arguments, then we're aggregating selectors, so we need\n      // to take the combineLatest of them before calling the map function.\n      observable$ = combineLatest(observables).pipe(\n        config.debounce ? debounceSync() : (source$) => source$,\n        map((projectorArgs) => projector(...projectorArgs))\n      );\n    }\n\n    return observable$.pipe(\n      distinctUntilChanged(),\n      shareReplay({\n        refCount: true,\n        bufferSize: 1,\n      }),\n      takeUntil(this.destroy$)\n    );\n  }\n\n  /**\n   * Creates an effect.\n   *\n   * This effect is subscribed to for the life of the @Component.\n   * @param generator A function that takes an origin Observable input and\n   *     returns an Observable. The Observable that is returned will be\n   *     subscribed to for the life of the component.\n   * @return A function that, when called, will trigger the origin Observable.\n   */\n  effect<\n    // This type quickly became part of effect 'API'\n    ProvidedType = void,\n    // The actual origin$ type, which could be unknown, when not specified\n    OriginType extends\n      | Observable<ProvidedType>\n      | unknown = Observable<ProvidedType>,\n    // Unwrapped actual type of the origin$ Observable, after default was applied\n    ObservableType = OriginType extends Observable<infer A> ? A : never,\n    // Return either an empty callback or a function requiring specific types as inputs\n    ReturnType = ProvidedType | ObservableType extends void\n      ? () => void\n      : (\n          observableOrValue: ObservableType | Observable<ObservableType>\n        ) => Subscription\n  >(generator: (origin$: OriginType) => Observable<unknown>): ReturnType {\n    const origin$ = new Subject<ObservableType>();\n    generator(origin$ as OriginType)\n      // tied to the lifecycle ðŸ‘‡ of ComponentStore\n      .pipe(takeUntil(this.destroy$))\n      .subscribe();\n\n    return (((\n      observableOrValue?: ObservableType | Observable<ObservableType>\n    ): Subscription => {\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      return observable$.pipe(takeUntil(this.destroy$)).subscribe((value) => {\n        // any new ðŸ‘‡ value is pushed into a stream\n        origin$.next(value);\n      });\n    }) as unknown) as ReturnType;\n  }\n}\n\nfunction processSelectorArgs<\n  Selectors extends Array<Observable<unknown> | SelectConfig | ProjectorFn>,\n  Result,\n  ProjectorFn = (...a: unknown[]) => Result\n>(\n  args: Selectors\n): {\n  observables: Observable<unknown>[];\n  projector: ProjectorFn;\n  config: Required<SelectConfig>;\n} {\n  const selectorArgs = Array.from(args);\n  // Assign default values.\n  let config: Required<SelectConfig> = { debounce: false };\n  let projector: ProjectorFn;\n  // Last argument is either projector or config\n  const projectorOrConfig = selectorArgs.pop() as ProjectorFn | SelectConfig;\n\n  if (typeof projectorOrConfig !== 'function') {\n    // We got the config as the last argument, replace any default values with it.\n    config = { ...config, ...projectorOrConfig };\n    // Pop the next args, which would be the projector fn.\n    projector = selectorArgs.pop() as ProjectorFn;\n  } else {\n    projector = projectorOrConfig;\n  }\n  // The Observables to combine, if there are any.\n  const observables = selectorArgs as Observable<unknown>[];\n  return {\n    observables,\n    projector,\n    config,\n  };\n}\n","import { EMPTY, Observable } from 'rxjs';\n\nimport { catchError, tap } from 'rxjs/operators';\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate.\n * It enforces that the error case is handled and that the effect would still be\n * running should an error occur.\n *\n * Takes an optional third argument for a `complete` callback.\n *\n * ```typescript\n * readonly dismissedAlerts = this.effect<Alert>(alert$ => {\n *  return alert$.pipe(\n *      concatMap(\n *          (alert) => this.alertsService.dismissAlert(alert).pipe(\n *              tapResponse(\n *                 (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *                 (error) => this.logError(error),\n *              ))));\n *   });\n * ```\n */\nexport function tapResponse<T>(\n  nextFn: (next: T) => void,\n  errorFn: (error: unknown) => void,\n  completeFn?: () => void\n): (source: Observable<T>) => Observable<T> {\n  return (source) =>\n    source.pipe(\n      tap({\n        next: nextFn,\n        error: errorFn,\n        complete: completeFn,\n      }),\n      catchError(() => EMPTY)\n    );\n}\n"]}