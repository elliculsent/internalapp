{"version":3,"file":"component-store.d.ts","sources":["component-store.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Observable, Subscription } from 'rxjs';\nimport { OnDestroy, InjectionToken } from '@angular/core';\nexport interface SelectConfig {\n    debounce?: boolean;\n}\nexport declare const INITIAL_STATE_TOKEN: InjectionToken<unknown>;\nexport declare type SelectorResults<Selectors extends Observable<unknown>[]> = {\n    [Key in keyof Selectors]: Selectors[Key] extends Observable<infer U> ? U : never;\n};\nexport declare type Projector<Selectors extends Observable<unknown>[], Result> = (...args: SelectorResults<Selectors>) => Result;\nexport declare class ComponentStore<T extends object> implements OnDestroy {\n    private readonly destroySubject$;\n    readonly destroy$: Observable<void>;\n    private readonly stateSubject$;\n    private isInitialized;\n    private notInitializedErrorMessage;\n    readonly state$: Observable<T>;\n    constructor(defaultState?: T);\n    /** Completes all relevant Observable streams. */\n    ngOnDestroy(): void;\n    /**\n     * Creates an updater.\n     *\n     * Throws an error if updater is called with synchronous values (either\n     * imperative value or Observable that is synchronous) before ComponentStore\n     * is initialized. If called with async Observable before initialization then\n     * state will not be updated and subscription would be closed.\n     *\n     * @param updaterFn A static updater function that takes 2 parameters (the\n     * current state and an argument object) and returns a new instance of the\n     * state.\n     * @return A function that accepts one argument which is forwarded as the\n     *     second argument to `updaterFn`. Every time this function is called\n     *     subscribers will be notified of the state change.\n     */\n    updater<ProvidedType = void, OriginType = ProvidedType, ValueType = OriginType, ReturnType = OriginType extends void ? () => void : (observableOrValue: ValueType | Observable<ValueType>) => Subscription>(updaterFn: (state: T, value: OriginType) => T): ReturnType;\n    /**\n     * Initializes state. If it was already initialized then it resets the\n     * state.\n     */\n    private initState;\n    /**\n     * Sets the state specific value.\n     * @param stateOrUpdaterFn object of the same type as the state or an\n     * updaterFn, returning such object.\n     */\n    setState(stateOrUpdaterFn: T | ((state: T) => T)): void;\n    /**\n     * Patches the state with provided partial state.\n     *\n     * @param partialStateOrUpdaterFn a partial state or a partial updater\n     * function that accepts the state and returns the partial state.\n     * @throws Error if the state is not initialized.\n     */\n    patchState(partialStateOrUpdaterFn: Partial<T> | ((state: T) => Partial<T>)): void;\n    protected get(): T;\n    protected get<R>(projector: (s: T) => R): R;\n    /**\n     * Creates a selector.\n     *\n     * @param projector A pure projection function that takes the current state and\n     *   returns some new slice/projection of that state.\n     * @param config SelectConfig that changes the behavior of selector, including\n     *   the debouncing of the values until the state is settled.\n     * @return An observable of the projector results.\n     */\n    select<Result>(projector: (s: T) => Result, config?: SelectConfig): Observable<Result>;\n    select<Selectors extends Observable<unknown>[], Result>(...args: [...selectors: Selectors, projector: Projector<Selectors, Result>]): Observable<Result>;\n    select<Selectors extends Observable<unknown>[], Result>(...args: [\n        ...selectors: Selectors,\n        projector: Projector<Selectors, Result>,\n        config: SelectConfig\n    ]): Observable<Result>;\n    /**\n     * Creates an effect.\n     *\n     * This effect is subscribed to for the life of the @Component.\n     * @param generator A function that takes an origin Observable input and\n     *     returns an Observable. The Observable that is returned will be\n     *     subscribed to for the life of the component.\n     * @return A function that, when called, will trigger the origin Observable.\n     */\n    effect<ProvidedType = void, OriginType extends Observable<ProvidedType> | unknown = Observable<ProvidedType>, ObservableType = OriginType extends Observable<infer A> ? A : never, ReturnType = ProvidedType | ObservableType extends void ? () => void : (observableOrValue: ObservableType | Observable<ObservableType>) => Subscription>(generator: (origin$: OriginType) => Observable<unknown>): ReturnType;\n}\n"]}